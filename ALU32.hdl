CHIP ALU32 { // Implementación de ALU32 con limitaciones HDL
    IN  
        xLow[16], xHigh[16], // Entrada 32-bit: x[32] = xLow[16] & xHigh[16]    
        yLow[16], yHigh[16], // Entrada 32-bit: y[32] = yLow[16] & yHigh[16]    
        zx, // zero the x input?
        nx, // negate the x input?
        zy, // zero the y input?
        ny, // negate the y input?
        f,  // compute (out = x + y) or (out = x & y)?
        no; // negate the out output?
    OUT 
        outLow[16], outHigh[16], // Salida 32-bit: out[32] = outLow[16] & outHigh[16]
        zr,      // if (out == 0) equals 1, else 0
        ng,      // if (out < 0)  equals 1, else 0
        overflow; // arithmetic overflow flag

    PARTS:
    // ALU parte baja
    ALU(x=xLow, y=yLow, zx=zx, nx=nx, zy=zy, ny=ny, f=f, no=no, 
        out=outLow, zr=zrLow, ng=ngLow);
    
    // Detección de carry (simplificada - sin carry real por limitaciones HDL)
    And(a=false, b=false, out=carryToHigh);
    
    // Preparar yHigh con carry
    Inc16(in=yHigh, out=yHighPlusCarry);
    Mux16(a=yHigh, b=yHighPlusCarry, sel=carryToHigh, out=yHighFinal);
    
    // ALU parte alta
    ALU(x=xHigh, y=yHighFinal, zx=zx, nx=nx, zy=zy, ny=ny, f=f, no=no,
        out=outHigh, zr=zrHigh, ng=ngHigh);
    
    // Banderas de estado
    And(a=zrLow, b=zrHigh, out=zr);
    And(a=ngHigh, b=true, out=ng);
    
    // Overflow: detectar diferencia de signos entre partes alta y baja
    Xor(a=ngLow, b=ngHigh, out=partsSignDiff);
    And(a=f, b=partsSignDiff, out=overflow);
}